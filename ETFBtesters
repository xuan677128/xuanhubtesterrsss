-- ================= XUAN HUB GUI (WindUI Version) =================
if game.PlaceId ~= 131623223084840 then
    game:GetService("Players").LocalPlayer:Kick("Xuan Hub not supported this game!")
    return
end

print("--===== XUAN HUB LOADED (WindUI) =====--")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

-- ================= LOAD WINDUI =================
local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

-- ================= SET FONT (IMPORTANT) =================
-- WindUI text font
WindUI:SetFont("rbxasset://fonts/families/GothamSSm.json")

-- ================= SETTINGS PERSISTENCE =================
local settingsFileName = "XuanHubSettings.json"
local defaultSettings = {
    autoCollectMoney = false,
    autoCollectRadioactive = false,
    autoSpin = false,
    spinDelay = 0.5,
    antiAfk = false,
    autoReconnect = false,
    autoUpgradeBase = false,
    autoUpgradeCarry = false,
    autoUpgradeSpeed = false,
    upgradeSpeedAmount = 1,
    autoRebirth = false,
    autoObby = false,
    -- UFO Event
    autoCollectUFO = false,
    -- UFO Spin
    autoSpinUFO = false,
    -- Money wheel spin
    autoSpinMoneyWheel = false,
    -- Money Event (Gold Bar)
    autoCollectGoldBar = false,
    -- Unlock Zoom
    unlockZoom = false,
    -- God Mode
    godMode = false,
    -- Tsunami tracker
	autoTsunamiTracker = false,
	-- Wider hitbox (tool reach)
	hitboxEnabled = false,
	hitboxWidth = 70,
}

local function loadSettings()
    if not isfolder("XuanHub") then
        makefolder("XuanHub")
    end

    if isfile("XuanHub/" .. settingsFileName) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile("XuanHub/" .. settingsFileName))
        end)
        if success and data then
            return data
        end
    end

    -- no settings file or parse failed: return a safe copy of defaults
    local ok, copy = pcall(function()
        return HttpService:JSONDecode(HttpService:JSONEncode(defaultSettings))
    end)
    if ok and type(copy) == "table" then
        return copy
    end

    return defaultSettings
end

local function saveSettings(settings)
    pcall(function()
        if not isfolder("XuanHub") then
            makefolder("XuanHub")
        end
        writefile("XuanHub/" .. settingsFileName, HttpService:JSONEncode(settings))
    end)
end

local savedSettings = loadSettings()

-- ================= CREATE WINDUI WINDOW =================
local Window = WindUI:CreateWindow({
    Folder = "XuanHub",
    Title = "XUAN HUB",
    Author = "by discord.gg/kaydensdens",
    Icon = "rbxassetid://103326199885496",
    Theme = "Midnight",
    Size = UDim2.fromOffset(640, 480),
    Draggable = true,
    HasOutline = true,
    OutlineThickness = 3,
    Resizable = true,
    Transparent = true,
    User = {
        Enabled = true,
        Anonymous = false,
    },
})

WindUI:Gradient({
    ["0"]   = { Color = Color3.fromHex("#1f1f23"), Transparency = 0 },
    ["100"] = { Color = Color3.fromHex("#18181b"), Transparency = 0 },
}, {
    Rotation = 0,
})


Window:EditOpenButton({
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

-- Add version tag
Window:Tag({
    Title = "Server: " .. tostring(game.PlaceVersion),
    Icon = "solar:server-bold",
    Color = Color3.fromRGB(255, 105, 180),
    Border = true,
})

-- ================= TABS =================


local BaseTab = Window:Tab({
    Title = "Main",
    Icon = "layers-2",
    Locked = false,
})

local EventTab = Window:Tab({
    Title = "Event",
    Icon = "star",
    Locked = false,
})

local AutoTab = Window:Tab({
    Title = "Auto",
    Icon = "refresh-cw",
    Locked = false,
})

local TsunamiTab = Window:Tab({
    Title = "Tsunami",
    Icon = "cloud-lightning",
    Locked = false,
})

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "settings",
    Locked = false,
})

-- Set Base tab as default
BaseTab:Select()

-- ================= FUNCTIONALITY LOGIC =================

-- Script running flag (to stop all loops when GUI is closed)
local scriptRunning = true

local character, humanoidRootPart
local EventFolder = nil

local PullDelay = 0.1
local HeightOffset = 3
local active = false
local spinning = false
local autoObby = false
local collectingMoney = false
local autoCollectUFO = false
local autoCollectGoldBar = false
local autoSpinUFO = false
local autoSpinMoneyWheel = false
local autoUpgradeBase = false
local autoUpgradeCarry = false
local autoUpgradeSpeed = false
local upgradeSpeedAmount = 1
local autoRebirth = false

-- Wider-hitbox runtime state
local widerHitboxEnabled = false
local widerHitboxWidth = 70 -- studs (default)
local widerHitboxConn = nil
local _widerHitbox_tracking = {}

-- Unlock Zoom state
local unlockZoomEnabled = false
local prevCameraMin = nil
local prevCameraMax = nil

-- God Mode state
local godModeEnabled = false
local godModeCharConn = nil
local godModeConns = {} -- map character -> {conns = {...}, modified = {...} }

-- Sell All confirmation
local lastSellAllClick = 0

-- Character handler (safe)
local function setupCharacter(char)
    character = char
    humanoidRootPart = char:WaitForChild("HumanoidRootPart", 10)
end

if player.Character then
    setupCharacter(player.Character)
end
player.CharacterAdded:Connect(setupCharacter)

-- Auto-Obby: finder that targets the new `RadioactiveMap_SharedInstances` layout (single-file change)
local function findRadioactiveRoot()
    -- primary: find the shared-instances container and locate the obby model inside it
    local rms = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
    if rms then
        -- prefer a model that contains ObbyEnd or has 'Obby' in its name
        for _, d in ipairs(rms:GetDescendants()) do
            if d:IsA("Model") and (d:FindFirstChild("ObbyEnd") or string.match(d.Name, "[Oo]bby")) then
                return d
            end
        end
        -- sometimes the obby is a direct child (e.g. Mud -> Obby); check first-level children
        for _, c in ipairs(rms:GetChildren()) do
            if c:IsA("Model") and c:FindFirstChild("ObbyEnd") then
                return c
            end
        end
    end

    -- fallback: top-level legacy names (kept minimal)
    local legacy = workspace:FindFirstChild("Radioactive") or workspace:FindFirstChild("RadioactiveMap")
    if legacy and legacy:IsA("Model") then
        return legacy
    end

    return nil
end

local function _handleObbyInteract(root)
    if not root or not humanoidRootPart or not autoObby then return end
    local obbyEnd = root:FindFirstChild("ObbyEnd")
    if obbyEnd and humanoidRootPart then
        pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 0) end)
        task.wait()
        pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 1) end)
    end
end

local function watchRadioactiveAppearances()
    -- immediate attempt for existing instances
    task.spawn(function()
        local root = findRadioactiveRoot()
        if root and autoObby then _handleObbyInteract(root) end
    end)

    -- workspace-level watcher for containers that appear dynamically
    workspace.ChildAdded:Connect(function(child)
        if not autoObby then return end
        if child.Name == "RadioactiveMap_SharedInstances" or child.Name == "Radioactive" then
            task.delay(0.4, function()
                local root = findRadioactiveRoot()
                if root then _handleObbyInteract(root) end
            end)
        end
    end)

    -- also listen for obby models appearing under the new shared-instances container
    local rms = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
    if rms then
        rms.ChildAdded:Connect(function(child)
            if not autoObby then return end
            -- if a model with Obby appears, attempt interaction
            if child:IsA("Model") and (child:FindFirstChild("ObbyEnd") or string.match(child.Name, "[Oo]bby")) then
                task.delay(0.25, function() _handleObbyInteract(child) end)
            end
        end)
    end
end

-- start the watcher (non-blocking)
watchRadioactiveAppearances()

-- Find EventParts WITHOUT BLOCKING GUI
task.spawn(function()
    while not EventFolder and scriptRunning do
        EventFolder = workspace:FindFirstChild("EventParts")
        task.wait(1)
    end
end)

-- Model part
local function getModelPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            model.PrimaryPart = v
            return v
        end
    end
end

-- Loop to pull models
task.spawn(function()
    while scriptRunning do
        if active and humanoidRootPart and EventFolder then
            for _, model in ipairs(EventFolder:GetChildren()) do
                if model:IsA("Model") then
                    local part = getModelPart(model)
                    if part then
                        model:SetPrimaryPartCFrame(
                            CFrame.new(humanoidRootPart.Position + Vector3.new(0, HeightOffset, 0))
                        )
                    end
                end
            end
        end
        task.wait(PullDelay)
    end
end)

-- Auto Spin logic
task.spawn(function()
    while scriptRunning do
        if spinning then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                "RF/WheelSpin.Roll"):InvokeServer()
            end)
            -- Get delay from input box with validation
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Money logic
local function findMyBase()
    for _, base in ipairs(workspace:WaitForChild("Bases"):GetChildren()) do
        if base:IsA("Model") then
            local holder = base:GetAttribute("Holder")
            if holder and holder == player.UserId then
                return base
            end
        end
    end
    return nil
end

-- Improved teleport helpers
local lastTeleportTime = 0
local TELEPORT_COOLDOWN = 1 -- seconds

local function getHomePart(base)
    if not base then return nil end
    local home = base:FindFirstChild("Home")
    if home and home:IsA("BasePart") then return home end
    return nil
end

local function findSafeCFrame(targetCFrame, upOffset)
    upOffset = upOffset or 6
    local origin = targetCFrame.Position + Vector3.new(0, 20, 0)
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { player.Character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, Vector3.new(0, -80, 0), params)
    if result and result.Position then
        return CFrame.new(result.Position + Vector3.new(0, upOffset, 0))
    end
    return targetCFrame + Vector3.new(0, upOffset, 0)
end

local function teleportToBaseSmooth()
    if tick() - lastTeleportTime < TELEPORT_COOLDOWN then
        WindUI:Notify({ Title = "Teleport", Content = "Teleport cooldown", Icon = "alert-triangle", Duration = 2 })
        return
    end
    lastTeleportTime = tick()

    local base = findMyBase()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        WindUI:Notify({ Title = "Teleport", Content = "Character not ready", Icon = "alert-triangle", Duration = 3 }); return
    end
    if not base then
        WindUI:Notify({ Title = "Teleport", Content = "No base found", Icon = "alert-triangle", Duration = 3 }); return
    end
    local home = getHomePart(base)
    if not home then
        WindUI:Notify({ Title = "Teleport", Content = "Base Home not found", Icon = "alert-triangle", Duration = 3 }); return
    end

    local targetCFrame = findSafeCFrame(home.CFrame, 6)
    local prevCanCollide = hrp.CanCollide
    pcall(function() hrp.CanCollide = false end)

    local ok, err = pcall(function()
        local tween = TweenService:Create(hrp, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            { CFrame = targetCFrame })
        tween:Play()
        tween.Completed:Wait()
    end)

    pcall(function() hrp.CanCollide = prevCanCollide end)

    if ok then
        WindUI:Notify({ Title = "Teleport", Content = "Teleported to base", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Teleport", Content = "Teleport failed: " .. tostring(err), Icon = "alert-triangle", Duration = 3 })
    end
end

task.spawn(function()
    while scriptRunning do
        if collectingMoney then
            local myBase = findMyBase()
            if myBase then
                for i = 1, 30 do
                    pcall(function()
                        local args = {
                            "Collect Money",
                            myBase.Name,
                            tostring(i)
                        }
                        local PlotAction = game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild(
                        "Net"):WaitForChild("RF/Plot.PlotAction")
                        PlotAction:InvokeServer(unpack(args))
                    end)
                    task.wait(0.01)
                end
            end
            task.wait(0.1)
        else
            task.wait(0.5)
        end
    end
end)

-- Generic coin collector used by multiple events (UFO, Radioactive)
local function _collectCoinsFromSources(opts)
    -- opts:
    --   rootPart (required): humanoid root part to touch with
    --   folderCandidates: array of workspace child-names to inspect (optional)
    --   rootModel: an Instance whose descendants should be searched (optional)
    --   nameMatchers: array of lowercase substrings to match coin names (optional)
    --   delayBetween = seconds between individual touches (optional)
    local rootPart = opts.rootPart
    if not rootPart then return end
    local nameMatchers = opts.nameMatchers or {}
    local delayBetween = tonumber(opts.delayBetween) or 0.05

    local function matchesName(n)
        if not n then return false end
        local ln = tostring(n):lower()
        if #nameMatchers == 0 then return true end
        for _, m in ipairs(nameMatchers) do
            if ln:find(m, 1, true) then return true end
        end
        return false
    end

    local function tryCollectFromFolder(folder)
        if not folder then return end
        for _, coin in ipairs(folder:GetChildren()) do
            local ok, cname = pcall(function() return coin.Name end)
            if ok and matchesName(cname) then
                local hitbox = coin:FindFirstChild("Hitbox") or coin:FindFirstChildWhichIsA("BasePart")
                if hitbox and hitbox:IsA("BasePart") then
                    pcall(function() firetouchinterest(rootPart, hitbox, 0) end)
                    task.wait()
                    pcall(function() firetouchinterest(rootPart, hitbox, 1) end)
                    task.wait(delayBetween)
                end
            end
        end
    end

    -- 1) explicit folder candidates
    if opts.folderCandidates then
        for _, fname in ipairs(opts.folderCandidates) do
            local f = workspace:FindFirstChild(fname)
            if f then tryCollectFromFolder(f) end
        end
    end

    -- 2) explicit root model (search its descendants for parts matching)
    if opts.rootModel then
        for _, d in ipairs(opts.rootModel:GetDescendants()) do
            if d:IsA("BasePart") then
                local ok, nm = pcall(function() return d.Name end)
                if ok and (matchesName(nm) or d:FindFirstChild("TouchInterest") or d:FindFirstChildOfClass("TouchTransmitter")) then
                    pcall(function() firetouchinterest(rootPart, d, 0) end)
                    task.wait()
                    pcall(function() firetouchinterest(rootPart, d, 1) end)
                    task.wait(delayBetween)
                end
            end
        end
    end
end

-- Auto Collect UFO (now uses generic collector)
task.spawn(function()
    while scriptRunning do
        if autoCollectUFO then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                _collectCoinsFromSources({
                    rootPart = hrp,
                    folderCandidates = { "UFOEventParts", "UFQEventParts" },
                    nameMatchers = { "ufo coin", "ufo" },
                    delayBetween = 0.05,
                })
            end)
            task.wait(0.2)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Radioactive (reuses the same collector logic)
task.spawn(function()
    while scriptRunning do
        if active then -- `active` is toggled by the Auto Collect Radioactive UI
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                -- prefer the new shared-instances root, then fallback to common folder names
                local rms = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
                if rms then
                    -- search the shared root for coin-like parts
                    _collectCoinsFromSources({ rootPart = hrp, rootModel = rms, nameMatchers = { "radioactive coin", "radioactive", "RadioactiveMap" }, delayBetween = 0.05 })
                else
                    -- fallback folder names (keeps compatibility)
                    _collectCoinsFromSources({ rootPart = hrp, folderCandidates = { "RadioactiveEventParts", "RadioactiveCoins", "MapVariants" }, nameMatchers = { "radioactive" }, delayBetween = 0.05 })
                end
            end)
            task.wait(0.2)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Gold Bar (Money Event) — specifically touch GoldBar.Main (or its BasePart)
task.spawn(function()
    while scriptRunning do
        if autoCollectGoldBar then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("MoneyEventParts")
                if not hrp or not folder then return end
                for _, gb in ipairs(folder:GetChildren()) do
                    if gb.Name == "GoldBar" or gb.Name:lower():find("gold") then
                        -- prefer the 'Main' part (some maps place the collectible under GoldBar.Main)
                        local mainPart = gb:FindFirstChild("Main")
                        if mainPart and mainPart:IsA("BasePart") then
                            pcall(function() firetouchinterest(hrp, mainPart, 0) end)
                            task.wait()
                            pcall(function() firetouchinterest(hrp, mainPart, 1) end)
                            task.wait(0.05)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(gb:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("main") or d.Name:lower():find("gold")) then
                                    pcall(function() firetouchinterest(hrp, d, 0) end)
                                    task.wait()
                                    pcall(function() firetouchinterest(hrp, d, 1) end)
                                    task.wait(0.05)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.2)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin Money Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinMoneyWheel then
            pcall(function()
                local args = { [1] = "Money", [2] = false }
                local ok, remote = pcall(function()
                    return game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):FindFirstChild("RF/WheelSpin.Roll")
                end)
                if ok and remote then
                    pcall(function() remote:InvokeServer(unpack(args)) end)
                end
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin UFO Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinUFO then
            pcall(function()
                local success, args = pcall(function()
                    return { "UFO", false }
                end)
                if success and args then
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                        "RF/WheelSpin.Roll"):InvokeServer(unpack(args))
                    end)
                end
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Upgrade Base Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeBase then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                "RE/Plot.UpgradeBase"):FireServer()
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Carry Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeCarry then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeCarry")
                    :InvokeServer()
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Speed Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeSpeed then
            pcall(function()
                local args = { upgradeSpeedAmount }
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeSpeed")
                    :InvokeServer(unpack(args))
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Rebirth Loop
task.spawn(function()
    while scriptRunning do
        if autoRebirth then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("Rebirth")
                    :InvokeServer()
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Anti-AFK (toggleable)
local antiAfkEnabled = savedSettings.antiAfk or false
local antiAfkConn = nil
local vu = game:GetService("VirtualUser")
local function enableAntiAfk()
    if antiAfkConn then return end
    antiAfkConn = player.Idled:Connect(function()
        vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    end)
end
local function disableAntiAfk()
    if antiAfkConn then
        antiAfkConn:Disconnect()
        antiAfkConn = nil
    end
end
if antiAfkEnabled then
    enableAntiAfk()
end

-- Auto Reconnect (toggleable)
local autoReconnectEnabled = savedSettings.autoReconnect or false
local autoReconnectConn = nil
local function enableAutoReconnect()
    if autoReconnectConn then return end
    local success, conn = pcall(function()
        return game.CoreGui.RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
            if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
                game:GetService("TeleportService"):Teleport(game.PlaceId, player)
            end
        end)
    end)
    if success and conn then
        autoReconnectConn = conn
    end
end
local function disableAutoReconnect()
    if autoReconnectConn then
        autoReconnectConn:Disconnect()
        autoReconnectConn = nil
    end
end
if autoReconnectEnabled then
    enableAutoReconnect()
end

-- Unlock Zoom handlers
local function enableUnlockZoom()
    if unlockZoomEnabled then return end
    unlockZoomEnabled = true
    -- store previous values if present
    pcall(function()
        prevCameraMin = player.CameraMinZoomDistance
        prevCameraMax = player.CameraMaxZoomDistance
    end)

    local applied = false
    -- Try to set on Player
    pcall(function()
        player.CameraMinZoomDistance = 0.5
        player.CameraMaxZoomDistance = 500
        applied = true
    end)

    -- Also try CurrentCamera in case of alternate API
    pcall(function()
        local cam = workspace and workspace.CurrentCamera
        if cam then
            pcall(function()
                cam.CameraMinZoomDistance = 0.5
                cam.CameraMaxZoomDistance = 500
                applied = true
            end)
        end
    end)

    if applied then
        WindUI:Notify({ Title = "Main", Content = "Zoom limits unlocked", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Main", Content = "Failed to change zoom limits", Icon = "alert-triangle", Duration = 4 })
    end
end

local function disableUnlockZoom()
    if not unlockZoomEnabled then return end
    unlockZoomEnabled = false
    local restored = false
    pcall(function()
        if prevCameraMin then
            player.CameraMinZoomDistance = prevCameraMin; restored = true
        end
        if prevCameraMax then
            player.CameraMaxZoomDistance = prevCameraMax; restored = true
        end
    end)
    pcall(function()
        local cam = workspace and workspace.CurrentCamera
        if cam then
            pcall(function()
                if prevCameraMin then cam.CameraMinZoomDistance = prevCameraMin end
                if prevCameraMax then cam.CameraMaxZoomDistance = prevCameraMax end
                restored = true
            end)
        end
    end)

    if restored then
        WindUI:Notify({ Title = "Main", Content = "Zoom limits restored", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Main", Content = "Zoom restore attempted", Icon = "check", Duration = 3 })
    end
end

-- ================= GOD MODE HELPERS =================
local godModeHealthConn = nil

local function applyGodMode(char)
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Disconnect old connection
    if godModeHealthConn then
        godModeHealthConn:Disconnect()
        godModeHealthConn = nil
    end
    
    -- Set infinite health
    pcall(function()
        humanoid.MaxHealth = math.huge
        humanoid.Health = math.huge
    end)
    
    -- Monitor health changes
    godModeHealthConn = humanoid.HealthChanged:Connect(function(health)
        if godModeEnabled and health < humanoid.MaxHealth then
            humanoid.Health = humanoid.MaxHealth
        end
    end)
    
    -- Destroy tsunami kill remote
    pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local packages = ReplicatedStorage:FindFirstChild("Packages")
        if packages then
            local net = packages:FindFirstChild("Net")
            if net then
                local kill = net:FindFirstChild("RE/TsunamiEventService/Kill")
                if kill then kill:Destroy() end
            end
        end
    end)
    
    -- Disable touch on all character parts
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.CanTouch = false end)
        end
    end
end

local function enableGodMode()
    if godModeEnabled then return end
    godModeEnabled = true
    
    -- Apply to current character
    if player.Character then
        applyGodMode(player.Character)
    end
    
    -- Handle character respawn (only set up once)
    if not godModeCharConn then
        godModeCharConn = player.CharacterAdded:Connect(function(char)
            task.wait(0.5)
            if godModeEnabled then
                applyGodMode(char)
            end
        end)
    end
    
    WindUI:Notify({ Title = "Main", Content = "God Mode enabled", Icon = "check", Duration = 3 })
end

local function disableGodMode()
    if not godModeEnabled then return end
    godModeEnabled = false
    
    -- Disconnect health monitoring
    if godModeHealthConn then
        godModeHealthConn:Disconnect()
        godModeHealthConn = nil
    end
    
    -- Disconnect character respawn handler
    if godModeCharConn then
        godModeCharConn:Disconnect()
        godModeCharConn = nil
    end
    
    local character = player.Character
    if not character then return end
    local humanoid = character:FindFirstChild("Humanoid")
    
    -- Reset health
    if humanoid then
        pcall(function()
            humanoid.MaxHealth = 100
            humanoid.Health = 100
        end)
    end
    
    -- Re-enable touch on all character parts
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.CanTouch = true end)
        end
    end
    
    WindUI:Notify({ Title = "Main", Content = "God Mode disabled", Icon = "check", Duration = 3 })
end

-- ================= TSUNAMI TRACKER =================
-- Creates a small ScreenGui that shows distance & color-coded status for nearby tsunamis
local RunService = game:GetService("RunService")
local tsunamiGui = nil
local tsunamiBox = nil
local tsunamiText = nil
local tsunamiHeartbeatConn = nil
local tsunamiEnabled = false

local function getTsunamiDistance()
    local character = player.Character
    if not character then return math.huge end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return math.huge end

    local closest = math.huge
    local activeTsunamis = workspace:FindFirstChild("ActiveTsunamis")
    if activeTsunamis then
        for i = 1, 6 do
            local wave = activeTsunamis:FindFirstChild("Wave" .. i)
            if wave then
                local hitbox = wave:FindFirstChild("Hitbox")
                if hitbox and hitbox:IsA("BasePart") then
                    local dist = (hitbox.Position - root.Position).Magnitude
                    if dist < closest then
                        closest = dist
                    end
                end
            end
        end
    end

    if closest == math.huge then
        for _, obj in pairs(workspace:GetChildren()) do
            if obj:IsA("Model") then
                if obj.Name:lower():find("tsunami") or obj.Name:lower():find("wave") then
                    for _, part in pairs(obj:GetDescendants()) do
                        if part:IsA("BasePart") then
                            local dist = (part.Position - root.Position).Magnitude
                            if dist < closest then
                                closest = dist
                            end
                        end
                    end
                end
            end
        end
    end

    return closest
end

local function createTsunamiGui()
    if tsunamiGui then return end
    tsunamiGui = Instance.new("ScreenGui")
    tsunamiGui.Name = "XuanTsunamiTracker"
    tsunamiGui.ResetOnSpawn = false
    tsunamiGui.Parent = player:WaitForChild("PlayerGui")

    tsunamiBox = Instance.new("Frame")
    tsunamiBox.Name = "TsunamiBox"
    tsunamiBox.Size = UDim2.fromOffset(220, 26)
    tsunamiBox.Position = UDim2.fromOffset(12, 12)
    tsunamiBox.BackgroundColor3 = Color3.fromRGB(30, 34, 45)
    tsunamiBox.BorderSizePixel = 0
    tsunamiBox.Parent = tsunamiGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = tsunamiBox

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(80, 80, 100)
    stroke.LineJoinMode = Enum.LineJoinMode.Round
    stroke.Parent = tsunamiBox

    tsunamiText = Instance.new("TextLabel")
    tsunamiText.Name = "TsunamiText"
    tsunamiText.Size = UDim2.new(1, -10, 1, -4)
    tsunamiText.Position = UDim2.fromOffset(8, 1)
    tsunamiText.BackgroundTransparency = 1
    tsunamiText.TextColor3 = Color3.fromRGB(255, 255, 255)
    tsunamiText.Text = "Tsunami: Safe (>1500m)"
    tsunamiText.Font = Enum.Font.Gotham
    tsunamiText.TextSize = 13
    tsunamiText.TextXAlignment = Enum.TextXAlignment.Left
    tsunamiText.TextYAlignment = Enum.TextYAlignment.Center
    tsunamiText.Parent = tsunamiBox

    tsunamiHeartbeatConn = RunService.Heartbeat:Connect(function()
        local dist = getTsunamiDistance()
        if dist < 1500 then
            if dist <= 500 then
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                tsunamiText.TextColor3 = Color3.new(1, 1, 1)
                tsunamiText.Text = "⚠️ Tsunami: " .. math.floor(dist) .. "m (DANGER)"
            elseif dist <= 1000 then
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(255, 150, 50)
                tsunamiText.TextColor3 = Color3.new(0, 0, 0)
                tsunamiText.Text = "Tsunami: " .. math.floor(dist) .. "m (WARNING)"
            else
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
                tsunamiText.TextColor3 = Color3.new(0, 0, 0)
                tsunamiText.Text = "Tsunami: " .. math.floor(dist) .. "m (SAFE)"
            end
        else
            tsunamiBox.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
            tsunamiText.TextColor3 = Color3.new(1, 1, 1)
            tsunamiText.Text = "Tsunami: Safe (>1500m)"
        end
    end)
end

local function destroyTsunamiGui()
    if tsunamiHeartbeatConn then
        tsunamiHeartbeatConn:Disconnect()
        tsunamiHeartbeatConn = nil
    end
    if tsunamiGui then
        tsunamiGui:Destroy()
        tsunamiGui = nil
        tsunamiBox = nil
        tsunamiText = nil
    end
end

local function enableTsunamiTracker()
    if tsunamiEnabled then return end
    tsunamiEnabled = true
    createTsunamiGui()
    WindUI:Notify({
        Title = "Tsunami",
        Content = "Tsunami tracker enabled",
        Icon = "check",
        Duration = 3,
    })
end

local function disableTsunamiTracker()
    if not tsunamiEnabled then return end
    tsunamiEnabled = false
    destroyTsunamiGui()
    WindUI:Notify({
        Title = "Tsunami",
        Content = "Tsunami tracker disabled",
        Icon = "check",
        Duration = 3,
    })
end

-- Add a section + toggle in the Tsunami tab
local TsunamiSection = TsunamiTab:Section({ Title = "Tsunami Tracker", Opened = true, })
TsunamiSection:Toggle({
    Title = "Tsunami Tracker",
    Desc = "Toggle tsunami tracker display",
    Value = savedSettings.autoTsunamiTracker,
    Callback = function(state)
        if state then
            enableTsunamiTracker()
        else
            disableTsunamiTracker()
        end
        savedSettings.autoTsunamiTracker = state
        saveSettings(savedSettings)
    end
})

-- Teleport to next gap (in front of player)
TsunamiSection:Button({
    Title = "TP Next Gap",
    Desc = "Teleport to the next gap ahead of you",
    Locked = false,
    Callback = function()
        local misc = workspace:FindFirstChild("Misc")
        local gapsFolder = misc and misc:FindFirstChild("Gaps")
        if not gapsFolder then
            WindUI:Notify({ Title = "Tsunami", Content = "Gaps not found", Icon = "alert-triangle", Duration = 3 })
            return
        end

        local gaps = gapsFolder:GetChildren()
        local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not root then
            WindUI:Notify({ Title = "Tsunami", Content = "Character not ready", Icon = "alert-triangle", Duration = 3 })
            return
        end

        local look = root.CFrame.LookVector
        local pos = root.Position
        local best, bestScore = nil, math.huge

        for _, g in ipairs(gaps) do
            local part = (g:IsA("BasePart") and g) or
            (g:IsA("Model") and (g.PrimaryPart or g:FindFirstChildWhichIsA("BasePart")))
            if part then
                local rel = part.Position - pos
                local proj = rel:Dot(look)
                if proj > 0 and proj < bestScore then
                    bestScore = proj
                    best = part
                end
            end
        end

        if best then
            root.CFrame = CFrame.new(best.Position + Vector3.new(0, 5, 0))
        else
            WindUI:Notify({ Title = "Tsunami", Content = "No gap ahead", Icon = "alert-triangle", Duration = 3 })
        end
    end
})

-- Teleport to previous gap (behind player)
TsunamiSection:Button({
    Title = "TP Previous Gap",
    Desc = "Teleport to the previous gap behind you",
    Locked = false,
    Callback = function()
        local misc = workspace:FindFirstChild("Misc")
        local gapsFolder = misc and misc:FindFirstChild("Gaps")
        if not gapsFolder then
            WindUI:Notify({ Title = "Tsunami", Content = "Gaps not found", Icon = "alert-triangle", Duration = 3 })
            return
        end

        local gaps = gapsFolder:GetChildren()
        local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not root then
            WindUI:Notify({ Title = "Tsunami", Content = "Character not ready", Icon = "alert-triangle", Duration = 3 })
            return
        end

        local look = root.CFrame.LookVector
        local pos = root.Position
        local best, bestScore = nil, -math.huge

        for _, g in ipairs(gaps) do
            local part = (g:IsA("BasePart") and g) or
            (g:IsA("Model") and (g.PrimaryPart or g:FindFirstChildWhichIsA("BasePart")))
            if part then
                local rel = part.Position - pos
                local proj = rel:Dot(look)
                if proj < 0 and proj > bestScore then
                    bestScore = proj
                    best = part
                end
            end
        end

        if best then
            root.CFrame = CFrame.new(best.Position + Vector3.new(0, 5, 0))
        else
            WindUI:Notify({ Title = "Tsunami", Content = "No gap behind", Icon = "alert-triangle", Duration = 3 })
        end
    end
})

-- Teleport to your base
TsunamiSection:Button({
    Title = "Teleport to Base",
    Desc = "Teleport to your base",
    Locked = false,
    Callback = function()
        teleportToBaseSmooth()
    end
})

-- Smart-tour helpers (used by the Auto Tour toggles)
local TweenService = game:GetService("TweenService")
_G.BaseTweenSpeed = 0.15
_G.AutoTourActive = false
_G.ReverseTourActive = false
_G.PostWaveBuffer = 0.05

local function GetNearestGapIndex()
    local gaps = workspace:FindFirstChild("Misc") and workspace.Misc:FindFirstChild("Gaps")
    local hrp = game.Players.LocalPlayer.Character and
    game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not gaps or not hrp then return 1 end
    local nearestIndex, minDistance = 1, math.huge
    for i = 1, 9 do
        local gap = gaps:FindFirstChild("Gap" .. i)
        if gap then
            local ok, gp = pcall(function() return gap:GetModelCFrame() end)
            if ok and gp then
                local dist = (hrp.Position - gp.Position).Magnitude
                if dist < minDistance then
                    minDistance, nearestIndex = dist, i
                end
            end
        end
    end
    return nearestIndex
end

local function IsPathClear(targetPos)
    local tsunamiFolder = workspace:FindFirstChild("ActiveTsunamis")
    if not tsunamiFolder then return true end
    local hrp = game.Players.LocalPlayer.Character and
    game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return true end
    local padding = 45
    local currentPos = hrp.Position
    local minX, maxX = math.min(currentPos.X, targetPos.X) - padding, math.max(currentPos.X, targetPos.X) + padding
    local minZ, maxZ = math.min(currentPos.Z, targetPos.Z) - padding, math.max(currentPos.Z, targetPos.Z) + padding
    for _, model in pairs(tsunamiFolder:GetChildren()) do
        for _, part in pairs(model:GetChildren()) do
            if part:IsA("BasePart") and string.find(string.lower(part.Name), "wave") then
                local wPos = part.Position
                if (wPos.X >= minX and wPos.X <= maxX) and (wPos.Z >= minZ and wPos.Z <= maxZ) then
                    return false
                end
            end
        end
    end
    return true
end

local function SmartMove(targetPos, areaName)
    local char = game.Players.LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        local finalSpeed = _G.BaseTweenSpeed
        local areaNum = tonumber(string.match(areaName, "%d+"))
        if areaNum and areaNum >= 6 then
            finalSpeed = _G.BaseTweenSpeed * 5.0
        end
        local info = TweenInfo.new(finalSpeed, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, info, { CFrame = CFrame.new(targetPos) })
        tween:Play()
        tween.Completed:Wait()
    end
end

-- Teleport to last gap (button)
TsunamiSection:Button({
    Title = "Smart Teleport to Last Gap",
    Desc = "Press to start teleport through gaps to the last gap",
    Locked = false,
    Callback = function()
        -- toggle behaviour on button press
        if _G.AutoTourActive then
            _G.AutoTourActive = false
            WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to Last Gap stopped", Icon = "check", Duration = 2 })
            return
        end

        _G.AutoTourActive = true
        _G.ReverseTourActive = false
        WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to Last Gap started", Icon = "check", Duration = 2 })
        task.spawn(function()
            local gaps = workspace:FindFirstChild("Misc") and workspace.Misc:FindFirstChild("Gaps")
            if not gaps then
                _G.AutoTourActive = false; return
            end
            while _G.AutoTourActive do
                local currentPosIndex = GetNearestGapIndex()
                for i = 1, 9 do
                    if not _G.AutoTourActive then break end
                    if i > currentPosIndex or (i == 1 and currentPosIndex == 9) then
                        local target = gaps:FindFirstChild("Gap" .. i)
                        if target then
                            local ok, mcf = pcall(function() return target:GetModelCFrame() end)
                            if ok and mcf then
                                local targetPos = (mcf * CFrame.new(0, -2, 0)).Position
                                while not IsPathClear(targetPos) and _G.AutoTourActive do task.wait(0.1) end
                                SmartMove(targetPos, "Gap" .. i)
                                task.wait(1.5)
                            end
                        end
                    end
                end
                task.wait(2)
            end
        end)
    end,
})

-- Teleport to first gap (reverse) - button
TsunamiSection:Button({
    Title = "Smart Teleport to First Gap",
    Desc = "Press to Automatically teleport through gaps to the first gap",
    Locked = false,
    Callback = function()
        if _G.ReverseTourActive then
            _G.ReverseTourActive = false
            WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to First Gap stopped", Icon = "check", Duration = 2 })
            return
        end

        _G.ReverseTourActive = true
        _G.AutoTourActive = false
        WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to First Gap started", Icon = "check", Duration = 2 })
        task.spawn(function()
            local gaps = workspace:FindFirstChild("Misc") and workspace.Misc:FindFirstChild("Gaps")
            if not gaps then
                _G.ReverseTourActive = false; return
            end
            while _G.ReverseTourActive do
                local currentPosIndex = GetNearestGapIndex()
                if currentPosIndex > 1 then
                    for i = currentPosIndex - 1, 1, -1 do
                        if not _G.ReverseTourActive then break end
                        local target = gaps:FindFirstChild("Gap" .. i)
                        if target then
                            local ok, mcf = pcall(function() return target:GetModelCFrame() end)
                            if ok and mcf then
                                local targetPos = (mcf * CFrame.new(0, -2, 0)).Position
                                while not IsPathClear(targetPos) and _G.ReverseTourActive do task.wait(0.1) end
                                SmartMove(targetPos, "Gap" .. i)
                                task.wait(1.5)
                            end
                        end
                    end
                end
                task.wait(2)
            end
        end)
    end,
})

-- ================= BASE TAB =================
local UpgBase = BaseTab:Section({ Title = "Main", Opened = true, })

-- Utilities section (visible)
local UtilitiesSection = BaseTab:Section({ Title = "Utilities", Opened = true, })

local UpgBaseOnce = UpgBase:Button({
    Title = "Upgrade Base",
    Desc = "Purchase one base upgrade",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
            "RE/Plot.UpgradeBase"):FireServer()
        end)
        WindUI:Notify({
            Title = "Upgraded",
            Content = "Base upgrade purchased!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Upgrade Carry (manual)
local UpgCarryOnce = UpgBase:Button({
    Title = "Upgrade Carry",
    Desc = "Purchase one carry upgrade",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeCarry")
                :InvokeServer()
        end)
        WindUI:Notify({
            Title = "Upgraded",
            Content = "Carry upgrade purchased!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Bring Back Celestial Timer
UpgBase:Button({
    Title = "Bring Back Celestial Timer",
    Desc = "Show the Celestial Timer visibility",
    Locked = false,
    Callback = function()
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui then
            local celestialTimer = playerGui:FindFirstChild("CelestialTimeLeft")
            if celestialTimer then
                celestialTimer.Enabled = not celestialTimer.Enabled
                local status = celestialTimer.Enabled and "shown" or "hidden"
                WindUI:Notify({
                    Title = "Celestial Timer",
                    Content = "Timer " .. status,
                    Icon = "check",
                    Duration = 3,
                })
            else
                WindUI:Notify({
                    Title = "Celestial Timer",
                    Content = "Timer not found",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
            end
        end
    end
})

-- Unlock Zoom Limit
UtilitiesSection:Toggle({
    Title = "Unlock Zoom Limit",
    Desc = "Unlock camera zoom limits",
    Value = savedSettings.unlockZoom,
    Callback = function(state)
        if state then
            enableUnlockZoom()
        else
            disableUnlockZoom()
        end
        savedSettings.unlockZoom = state
        saveSettings(savedSettings)
    end
})

-- God Mode
UtilitiesSection:Toggle({
    Title = "God Mode",
    Desc = "Immune To the tsunami for one time or for more than 3 waves if the tsunami is close to each other",
    Value = savedSettings.godMode,
    Callback = function(state)
        if state then
            enableGodMode()
        else
            disableGodMode()
        end
        savedSettings.godMode = state
        saveSettings(savedSettings)
    end
})

-- Wider hitbox helpers
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local BASE_SIZE = Vector3.new(4, 4, 4)
local MAX_SIZE = Vector3.new(150, 150, 150)

local function _collectToolHitboxes()
    table.clear(_widerHitbox_tracking)
    -- Backpack
    if LocalPlayer:FindFirstChild("Backpack") then
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                local hb = tool:FindFirstChild("Hitbox")
                if hb and hb:IsA("BasePart") then
                    _widerHitbox_tracking[hb] = { part = hb, origSize = hb.Size, origTransparency = hb.Transparency }
                end
            end
        end
    end
    -- Character (equipped)
    if LocalPlayer.Character then
        for _, tool in ipairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") then
                local hb = tool:FindFirstChild("Hitbox")
                if hb and hb:IsA("BasePart") then
                    _widerHitbox_tracking[hb] = { part = hb, origSize = hb.Size, origTransparency = hb.Transparency }
                end
            end
        end
    end
end

local function _applyWiderHitboxes()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    _collectToolHitboxes()
    if not next(_widerHitbox_tracking) then return end

    -- find nearby players
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local nearby = {}
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local d = (pl.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
            if d <= 50 then table.insert(nearby, pl.Character.HumanoidRootPart) end
        end
    end

    for hb, meta in pairs(_widerHitbox_tracking) do
        if #nearby == 0 then
            hb.Size = meta.origSize or BASE_SIZE
            hb.Transparency = meta.origTransparency or 1
            hb.CanCollide = false
        else
            local targetPos = hrp.Position
            if #nearby == 1 then
                local dir = (nearby[1].Position - hrp.Position).Unit
                targetPos = nearby[1].Position + dir * 2
            else
                local total = Vector3.new()
                for _, p in ipairs(nearby) do
                    total = total + p.Position
                end
                targetPos = total / #nearby
            end
            local finalSize = ( #nearby == 1 ) and Vector3.new(widerHitboxWidth, widerHitboxWidth, widerHitboxWidth + 8) or MAX_SIZE
            hb.Size = finalSize
            hb.Position = targetPos
            hb.Transparency = 0.7
            hb.CanCollide = false
        end
    end
end

local function startWiderHitbox()
    if widerHitboxConn then return end
    widerHitboxEnabled = true
    widerHitboxConn = RunService.Heartbeat:Connect(function()
        if widerHitboxEnabled then _applyWiderHitboxes() end
    end)
    -- react to tool/character changes
    LocalPlayer.Backpack.ChildAdded:Connect(function(child) task.wait(0.1); _collectToolHitboxes() end)
    LocalPlayer.CharacterAdded:Connect(function() task.wait(1); _collectToolHitboxes() end)
    WindUI:Notify({ Title = "Utilities", Content = "Wider hitbox enabled", Icon = "check", Duration = 2 })
end

local function stopWiderHitbox()
    widerHitboxEnabled = false
    if widerHitboxConn then
        widerHitboxConn:Disconnect()
        widerHitboxConn = nil
    end
    -- restore originals
    for hb, meta in pairs(_widerHitbox_tracking) do
        pcall(function()
            if meta.part and meta.origSize then meta.part.Size = meta.origSize end
            if meta.part and meta.origTransparency then meta.part.Transparency = meta.origTransparency end
            if meta.part then meta.part.CanCollide = false end
        end)
    end
    table.clear(_widerHitbox_tracking)
    WindUI:Notify({ Title = "Utilities", Content = "Wider hitbox disabled", Icon = "check", Duration = 2 })
end

-- Utilities: Wider hitbox UI
UtilitiesSection:Toggle({
    Title = "Enable Wider Hitbox",
    Desc = "Expand tool hitboxes when players are nearby",
    Value = savedSettings.hitboxEnabled,
    Callback = function(state)
        savedSettings.hitboxEnabled = state
        saveSettings(savedSettings)
        if state then
            widerHitboxWidth = tonumber(savedSettings.hitboxWidth) or 70
            startWiderHitbox()
        else
            stopWiderHitbox()
        end
    end
})

UtilitiesSection:Slider({
    Title = "Hitbox Width",
    Desc = "How wide the hitbox becomes (studs)",
    Step = 1,
    Value = { Min = 20, Max = 120, Default = savedSettings.hitboxWidth or 70 },
    Callback = function(value)
        widerHitboxWidth = math.clamp(tonumber(value) or 70, 8, 200)
        savedSettings.hitboxWidth = widerHitboxWidth
        saveSettings(savedSettings)
    end
})

-- Buttons moved from Main (simplified)
local SellAllBtn = UpgBase:Button({
    Title = "Sell All Inventory",
    Desc = "Double-click to sell your entire inventory",
    Locked = false,
    Callback = function()
        local currentTime = tick()
        if currentTime - lastSellAllClick < 2 then
            -- Double-click detected
            local result = game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SellAll"):InvokeServer()
            if result == false or result == nil then
                WindUI:Notify({
                    Title = "Sold",
                    Content = "You don't have any Brainrots in your Inventory.",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
            else
                WindUI:Notify({
                    Title = "Sold",
                    Content = "Successfully Sold All Brainrots!",
                    Icon = "check",
                    Duration = 3,
                })
            end
            lastSellAllClick = 0
        else
            -- First click
            lastSellAllClick = currentTime
            WindUI:Notify({
                Title = "Sell All",
                Content = "Click again to confirm",
                Icon = "alert-triangle",
                Duration = 2,
            })
        end
    end
})

local SellHeldBtn = UpgBase:Button({
    Title = "Sell Held Tool",
    Desc = "Sells the brainrot you are currently holding",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SellTool"):InvokeServer()
        end)
        WindUI:Notify({
            Title = "Sold",
            Content = "Held tool sold!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Unlock VIP Walls (one-shot button)
UpgBase:Button({
    Title = "Unlock VIP Walls",
    Desc = "Disable Shield of VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local walls = workspace:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    pcall(function() v:Destroy() end)
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: "..tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})


-- ================= EVENT TAB =================
local RadioactiveSection = EventTab:Section({
    Title = "Radioactive Event",
    Opened = false,
})

-- Auto Collect Radioactive
RadioactiveSection:Toggle({
    Title = "Auto Collect Radioactive Coins",
    Desc = "(Patched, it will still collect but not many)",
    Value = savedSettings.autoCollectRadioactive,
    Callback = function(state)
        active = state
        savedSettings.autoCollectRadioactive = state
        saveSettings(savedSettings)
    end
})

RadioactiveSection:Space()

-- Auto Spin
RadioactiveSection:Toggle({
    Title = "Auto Spin Radioactive Wheel",
    Desc = "Automatically spins the radioactive wheel",
    Value = savedSettings.autoSpin,
    Callback = function(state)
        spinning = state
        savedSettings.autoSpin = state
        saveSettings(savedSettings)
    end
})

RadioactiveSection:Input({
    Title = "Spin Delay",
    Value = tostring(savedSettings.spinDelay),
    Placeholder = "0.5",
    Callback = function(value)
        local delay = tonumber(value)
        if delay and delay >= 0.1 then
            savedSettings.spinDelay = delay
            saveSettings(savedSettings)
        end
    end
})

RadioactiveSection:Space()

-- Auto Obby
RadioactiveSection:Toggle({
    Title = "Auto Complete Radioactive Obby",
    Desc = "Automatically completes the obby",
    Value = savedSettings.autoObby,
    Callback = function(state)
        autoObby = state
        savedSettings.autoObby = state
        saveSettings(savedSettings)
    end
})

-- UFO Event
local UFOSection = EventTab:Section({
    Title = "UFO Event",
    Opened = true,
})

UFOSection:Toggle({
    Title = "Auto Collect UFO Coins",
    Desc = "Automatically collects UFO coins",
    Value = savedSettings.autoCollectUFO,
    Callback = function(state)
        autoCollectUFO = state
        savedSettings.autoCollectUFO = state
        saveSettings(savedSettings)
    end
})

UFOSection:Toggle({
    Title = "Auto Spin UFO Wheel",
    Desc = "Automatically spins the UFO wheel",
    Value = savedSettings.autoSpinUFO,
    Callback = function(state)
        autoSpinUFO = state
        savedSettings.autoSpinUFO = state
        saveSettings(savedSettings)
    end
})

-- Money Event
local MoneySection = EventTab:Section({
    Title = "Money Event",
    Opened = true,
})

MoneySection:Toggle({
    Title = "Auto Collect Gold Bar",
    Desc = "Automatically collect Gold Bars",
    Value = savedSettings.autoCollectGoldBar,
    Callback = function(state)
        autoCollectGoldBar = state
        savedSettings.autoCollectGoldBar = state
        saveSettings(savedSettings)
    end
})

MoneySection:Toggle({
    Title = "Auto Spin Money Wheel",
    Desc = "Automatically spin the money wheel",
    Value = savedSettings.autoSpinMoneyWheel,
    Callback = function(state)
        autoSpinMoneyWheel = state
        savedSettings.autoSpinMoneyWheel = state
        saveSettings(savedSettings)
    end
})

MoneySection:Button({
    Title = "Complete Money Obbies",
    Desc = "Complete all 3 money obbies (1s delay each)",
    Callback = function()
        task.spawn(function()
            local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if not rootPart then
                WindUI:Notify({ Title = "Money Event", Content = "Character not ready", Icon = "alert-triangle", Duration = 3 })
                return
            end
            
            local moneyMap = workspace:FindFirstChild("MoneyMap_SharedInstances")
            if not moneyMap then
                WindUI:Notify({ Title = "Money Event", Content = "MoneyMap not found", Icon = "alert-triangle", Duration = 3 })
                return
            end
            
            -- Complete Obby 1 first
            local obby1End = moneyMap:FindFirstChild("MoneyObby1End")
            if obby1End and obby1End:FindFirstChild("TouchInterest") then
                pcall(function()
                    firetouchinterest(rootPart, obby1End, 0)
                    task.wait(0.1)
                    firetouchinterest(rootPart, obby1End, 1)
                end)
                WindUI:Notify({ Title = "Money Event", Content = "Completed Obby 1", Icon = "check", Duration = 2 })
                task.wait(1)
            end
            
            -- Touch Checkpoint 3 before Obby 2
            local checkpoint3 = moneyMap:FindFirstChild("MoneyCheckpoint3")
            if checkpoint3 and checkpoint3:FindFirstChild("TouchInterest") then
                pcall(function()
                    firetouchinterest(rootPart, checkpoint3, 0)
                    task.wait(0.1)
                    firetouchinterest(rootPart, checkpoint3, 1)
                end)
                WindUI:Notify({ Title = "Money Event", Content = "Reached Checkpoint 3", Icon = "check", Duration = 2 })
                task.wait(1)
            end
            
            -- Complete Obby 2 second
            local obby2End = moneyMap:FindFirstChild("MoneyObby2End")
            if obby2End and obby2End:FindFirstChild("TouchInterest") then
                pcall(function()
                    firetouchinterest(rootPart, obby2End, 0)
                    task.wait(0.1)
                    firetouchinterest(rootPart, obby2End, 1)
                end)
                WindUI:Notify({ Title = "Money Event", Content = "Completed Obby 2", Icon = "check", Duration = 2 })
                task.wait(1)
            end
            
            -- Complete Obby 3 last
            local obby3End = moneyMap:FindFirstChild("MoneyObby3End")
            if obby3End and obby3End:FindFirstChild("TouchInterest") then
                pcall(function()
                    firetouchinterest(rootPart, obby3End, 0)
                    task.wait(0.1)
                    firetouchinterest(rootPart, obby3End, 1)
                end)
                WindUI:Notify({ Title = "Money Event", Content = "Completed Obby 3", Icon = "check", Duration = 2 })
            end
            
            WindUI:Notify({ Title = "Money Event", Content = "All obbies completed!", Icon = "check", Duration = 3 })
        end)
    end
})

-- ================= AUTO TAB =================
local AutoSection = AutoTab:Section({ Title = "Auto Features", Opened = true, })

-- Auto Upgrade Base
local AutoUpgradeBaseToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Base",
    Desc = "Automatically upgrades your base",
    Value = savedSettings.autoUpgradeBase,
    Callback = function(state)
        autoUpgradeBase = state
        savedSettings.autoUpgradeBase = state
        saveSettings(savedSettings)
    end
})

-- Auto Collect Money
local AutoCollectMoneyToggle = AutoSection:Toggle({
    Title = "Auto Collect Money",
    Desc = "Automatically collects money from your base",
    Value = savedSettings.autoCollectMoney,
    Callback = function(state)
        collectingMoney = state
        savedSettings.autoCollectMoney = state
        saveSettings(savedSettings)
    end
})

-- Auto Upgrade Carry
local AutoUpgradeCarryToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Carry",
    Desc = "Automatically upgrades carry capacity",
    Value = savedSettings.autoUpgradeCarry,
    Callback = function(state)
        autoUpgradeCarry = state
        savedSettings.autoUpgradeCarry = state
        saveSettings(savedSettings)
    end
})

-- Auto Upgrade Speed
local AutoUpgradeSpeedToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Speed",
    Desc = "Automatically upgrades movement speed",
    Value = savedSettings.autoUpgradeSpeed,
    Callback = function(state)
        autoUpgradeSpeed = state
        savedSettings.autoUpgradeSpeed = state
        saveSettings(savedSettings)
    end
})

local SpeedAmountDropdown = AutoSection:Dropdown({
    Title = "Speed Amount",
    Desc = "Select upgrade speed amount",
    Values = { "1", "5", "10" },
    Value = tostring(savedSettings.upgradeSpeedAmount),
    Multi = false,
    AllowNone = false,
    Callback = function(option)
        upgradeSpeedAmount = tonumber(option)
        savedSettings.upgradeSpeedAmount = upgradeSpeedAmount
        saveSettings(savedSettings)
        print("Speed amount set to: " .. tostring(option))
    end
})

-- Auto Rebirth
local AutoRebirthToggle = AutoSection:Toggle({
    Title = "Auto Rebirth",
    Desc = "Automatically rebirths when possible",
    Value = savedSettings.autoRebirth,
    Callback = function(state)
        autoRebirth = state
        savedSettings.autoRebirth = state
        saveSettings(savedSettings)
    end
})

-- ================= MISC TAB =================
local MiscSettings = MiscTab:Section({
    Title = "Game Settings",
    Opened = true,
})

-- Anti-AFK
MiscSettings:Toggle({
    Title = "Anti-AFK",
    Desc = "Prevents Roblox from kicking you after 20 minutes of inactivity",
    Value = savedSettings.antiAfk,
    Callback = function(state)
        antiAfkEnabled = state
        savedSettings.antiAfk = state
        saveSettings(savedSettings)
        if state then
            enableAntiAfk()
        else
            disableAntiAfk()
        end
    end
})

MiscSettings:Space()

-- Auto Reconnect
MiscSettings:Toggle({
    Title = "Auto Reconnect",
    Desc = "Automatically rejoins the game when you get disconnected",
    Value = savedSettings.autoReconnect,
    Callback = function(state)
        autoReconnectEnabled = state
        savedSettings.autoReconnect = state
        saveSettings(savedSettings)
        if state then
            enableAutoReconnect()
        else
            disableAutoReconnect()
        end
    end
})

MiscTab:Space()
MiscTab:Space()

MiscTab:Section({
    Title = "Server Actions",
    Opened = true,
})

local ServerGroup = MiscTab:Group()

ServerGroup:Button({
    Title = "Server Hop",
    Icon = "solar:refresh-bold",
    Color = Color3.fromRGB(255, 105, 180),
    Justify = "Center",
    Callback = function()
        local servers = {}
        local req = game:HttpGet("https://games.roblox.com/v1/games/" ..
        game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100")
        local body = HttpService:JSONDecode(req)

        if body and body.data then
            for _, v in pairs(body.data) do
                if v.id ~= game.JobId and v.playing < v.maxPlayers then
                    table.insert(servers, v)
                end
            end

            if #servers > 0 then
                local randomServer = servers[math.random(1, #servers)]
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, randomServer.id, player)
            end
        end
    end
})

ServerGroup:Space()

ServerGroup:Button({
    Title = "Rejoin",
    Icon = "solar:restart-bold",
    Color = Color3.fromRGB(255, 105, 180),
    Justify = "Center",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, player)
    end
})

-- ================= SETTINGS APPLY =================
task.spawn(function()
    task.wait(0.5) -- Wait for GUI to fully load

    -- Apply Auto Collect Money
    if savedSettings.autoCollectMoney then
        collectingMoney = true
    end

    -- Apply Auto Collect Radioactive
    if savedSettings.autoCollectRadioactive then
        active = true
    end

    -- Apply Auto Spin
    if savedSettings.autoSpin then
        spinning = true
    end

    -- Apply Auto Upgrade Base
    if savedSettings.autoUpgradeBase then
        autoUpgradeBase = true
    end

    -- Apply Auto Upgrade Carry
    if savedSettings.autoUpgradeCarry then
        autoUpgradeCarry = true
    end

    -- Apply Auto Upgrade Speed
    if savedSettings.autoUpgradeSpeed then
        autoUpgradeSpeed = true
    end

    -- Apply Upgrade Speed Amount
    if savedSettings.upgradeSpeedAmount then
        upgradeSpeedAmount = savedSettings.upgradeSpeedAmount
    end

    -- Apply Auto Rebirth
    if savedSettings.autoRebirth then
        autoRebirth = true
    end

    -- Apply Auto Obby
    if savedSettings.autoObby then
        autoObby = true

        -- quick-start: try to interact with any existing obby using the resilient finder
        task.spawn(function()
            local root = findRadioactiveRoot()
            if root then
                local obbyEnd = root:FindFirstChild("ObbyEnd")
                if obbyEnd and humanoidRootPart then
                    pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 0) end)
                    task.wait()
                    pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 1) end)
                end
            end
        end)
    end

    -- Apply Auto Collect UFO
    if savedSettings.autoCollectUFO then
        autoCollectUFO = true
    end

    -- Apply Auto Collect Gold Bar (Money Event)
    if savedSettings.autoCollectGoldBar then
        autoCollectGoldBar = true
    end

    -- Apply Auto Spin Money Wheel
    if savedSettings.autoSpinMoneyWheel then
        autoSpinMoneyWheel = true
    end

    -- Apply Auto Spin UFO Wheel
    if savedSettings.autoSpinUFO then
        autoSpinUFO = true
    end

    -- Apply God Mode
    if savedSettings.godMode then
        godModeEnabled = true
        enableGodMode()
    end

    -- Apply Unlock Zoom
    if savedSettings.unlockZoom then
        unlockZoomEnabled = true
        enableUnlockZoom()
    else
        unlockZoomEnabled = false
        disableUnlockZoom()
    end

    -- Apply Anti-AFK
    if savedSettings.antiAfk then
        antiAfkEnabled = true
        enableAntiAfk()
    else
        antiAfkEnabled = false
        disableAntiAfk()
    end

    -- Apply Auto Reconnect
    if savedSettings.autoReconnect then
        autoReconnectEnabled = true
        enableAutoReconnect()
    else
        autoReconnectEnabled = false
        disableAutoReconnect()
    end

    -- Apply Tsunami Tracker
    if savedSettings.autoTsunamiTracker then
        enableTsunamiTracker()
    else
        disableTsunamiTracker()
    end
end)

-- ================= FINALIZE =================
WindUI:Notify({
    Title = "Xuan Hub Loaded",
    Content = "Welcome " .. player.DisplayName .. "!",
    Icon = "check",
    Duration = 5,
})

print("--===== XUAN HUB READY =====--")
